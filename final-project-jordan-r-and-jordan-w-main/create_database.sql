/*
Assignment: Final Project
Course:     DAT 153
Term:       Spring 2025
Author:     Jordan Whitehouse & Jordan Reed
Script:     Database Creation Script


Part 1: Creating the Tables
*/

-- 1) Create the celebrity table (stores core info about each celebrity- one row per celebrity, even if they return in future seasons ** AND IS SEPARATE** from season-specific data**)
-- NOTE - a celebrity can appear in more than one season (ex: season 15 is an all-stars season), so we avoid repeating the same name, industry, or country data)
CREATE TABLE public.celebrity
(
    celebrity_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    celebrity_name        VARCHAR(100) NOT NULL,
    celebrity_industry    VARCHAR(100),
    celebrity_homestate   VARCHAR(50),
    celebrity_homecountry VARCHAR(50)
);

-------------------------------------------------------------------------------------------
-- 2) Create the season table (uniquely identifies a season and stores info specific to that season of the show)
-- NOTE - this helps track which season a celebrity competed in b/c season 15 used past celebs
CREATE TABLE public.season
(
    season_id     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    season_number INTEGER UNIQUE NOT NULL CHECK (season_number > 0),
    premiere_date DATE NOT NULL CHECK (premiere_date > DATE '2005-01-01'),
    finale_date DATE NOT NULL CHECK (premiere_date > DATE '2005-01-01'),
    premiere_views INTEGER,
    finale_views INTEGER,
    num_of_episodes INTEGER
);

--------------------------------------------------------------------------------------------
-- 3) Create a ballroom partners table (uniquely identifies every ballroom partner professional)
CREATE TABLE public.pros
(
    pro_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pro_name VARCHAR UNIQUE NOT NULL
);

------------------------------------------------------------------------------------------
-- 4) Create the celebrity_season table (serves as a junction table to model each celebrity's participation in each season- i.e. connects each celebrity to a season they competed in)
-- NOTE - captures **SEASON-SPECIFIC** attributes like their partner and how far they got. A celebrity may be on multiple seasons AND have different results AND be assigned different partners
CREATE TABLE public.celebrity_season
(
    celebrity_season_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    celebrity_id        INTEGER NOT NULL REFERENCES celebrity (celebrity_id) ON DELETE CASCADE,
    season_id           INTEGER NOT NULL REFERENCES season (season_id) ON DELETE CASCADE,
    pro_id              INTEGER NOT NULL REFERENCES pros (pro_id) ON DELETE CASCADE,
    result              VARCHAR(50), -- e.g. "Eliminated Week 3", "2nd place"
    placement           INTEGER CHECK (placement > 0),
    UNIQUE (celebrity_id, season_id)
);

-----------------------------------------------------------------------------------------
-- 5) Create judges table (uniquely identifies every main judge)
CREATE TABLE public.judges
(
    judge_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    judge_name VARCHAR UNIQUE NOT NULL
);

----------------------------------------------------------------------------------------
-- 6) Create the score table (tracks the judges score for each celebrity in a specific week of a specific season- stores the weekly score of one per week per celeb per season)
-- NOTE - this follow the rule that ONLY one score per week is recorded, EVEN if multiple dances are performed (the scores provided in the data set are the avg. of each dance done in that week from each judge)
CREATE TABLE public.score
(
    score_id            INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    celebrity_season_id INTEGER NOT NULL REFERENCES celebrity_season (celebrity_season_id) ON DELETE CASCADE,
    week                INTEGER NOT NULL CHECK (week BETWEEN 1 AND 15),
    judge1_score        NUMERIC(4, 2),
    judge2_score        NUMERIC(4, 2),
    judge3_score        NUMERIC(4, 2),
    judge4_score        NUMERIC(4, 2),
    UNIQUE (celebrity_season_id, week)
);

-- **AFTER creating the score table in SQL AND after populating the data from python-- get rid of the rows when there are no scores from the judges for the contestant (i.e. meaning they did not make it to that week)
-- **also remember that the scores were averaged into one score if there was more than one dance done a night (i.e. there is only one score given each week for each celeb, even if they did multiple dances/performances)
-- the following delete statement must be run AFTER running the SQL create table score statement and populating the data from python
-- **Personal NOTE: PostgreSQL’s IDENTITY column does not reuse values once they’ve been generated—even if the row is later deleted or the insertion failed.
-- The deletion removes rows—but PostgreSQL does not reassign the deleted performance_ids, so the sequence continues from the last used number.
DELETE
FROM public.score
WHERE (judge1_score IS NULL OR judge1_score = 0)
  AND (judge2_score IS NULL OR judge2_score = 0)
  AND (judge3_score IS NULL OR judge3_score = 0)
  AND (judge4_score IS NULL OR judge4_score = 0);

-----------------------------------------------------------------------------------------
-- 7) Create the judges score table (required for normalization)
CREATE TABLE public.judges_score
(
    judges_score_id     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    celebrity_season_id INTEGER       NOT NULL REFERENCES celebrity_season (celebrity_season_id) ON DELETE CASCADE,
    judge_id            INTEGER       NOT NULL REFERENCES judges (judge_id) ON DELETE CASCADE,
    score_id            INTEGER       NOT NULL REFERENCES score (score_id) ON DELETE CASCADE,
    score               NUMERIC(4, 2) NOT NULL
);

--------------------------------------------------------------------------------------
-- 8) Create a Dance Style Table (reference table for standardized dance types)
CREATE TABLE public.dance_styles
(
    dance_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    dance_name varchar(300) UNIQUE NOT NULL
);

---------------------------------------------------------------------------------------
-- 9) Create the dances performed table (stores each dance style performed by a celebrity in a specific week and season)
-- NOTE - b/c a celebrity might perform multiple dance styles in the SAME week, this needs to be SEPARATED from the score table to avoid violating 3NF
CREATE TABLE public.dances_performed
(
    performance_dance_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    celebrity_season_id  INTEGER NOT NULL REFERENCES celebrity_season (celebrity_season_id) ON DELETE CASCADE,
    dance_id             INTEGER NOT NULL REFERENCES dance_styles (dance_id) ON DELETE CASCADE,
    week                 INTEGER NOT NULL CHECK (week BETWEEN 1 AND 15)
);

-----------------------------------------------------------------------------------------------
-- 10) Create Hosts table (uniquely identifies every host)
CREATE TABLE public.hosts
(
    host_id   SERIAL PRIMARY KEY,
    host_name VARCHAR(100) UNIQUE NOT NULL
);

--------------------------------------------------------------------------------------------------------------
-- 11) Create season hosts table (acts a junction/connection table to connect hosts by their host id to the seasons they hosted)
CREATE TABLE public.host_season
(
    host_season_id SERIAL PRIMARY KEY,
    host_id        INTEGER NOT NULL REFERENCES hosts (host_id) ON DELETE CASCADE,
    season_id      INTEGER NOT NULL REFERENCES season (season_id) ON DELETE CASCADE,
    UNIQUE (season_id, host_id)
);

-- Drop Tables for testing code:
/*
drop table if exists
    public.celebrity,
    public.season,
    public.pros,
    public.celebrity_season,
    public.judges,
    public.score,
    public.judges_score,
    public.dance_styles,
    public.dances_performed,
    public.hosts,
    public.host_season
cascade;
 */
------------------------------------------------------------------------------------------
/*

Part 2: Implementing a View & One Function or Stored Procedure
*/

-- 1) View: Total Scores
-- This view dynamically calculates the total judge score per celebrity per week per season, regardless of whether there were 3 or 4 judges:
CREATE OR REPLACE VIEW total_scores AS
SELECT cs.celebrity_season_id,
       cs.celebrity_id,
       c.celebrity_name,
       s.season_number,
       sc.week,
       COUNT(js.judge_id)      AS num_judges,
       ROUND(SUM(js.score), 2) AS total_score
FROM judges_score js
         JOIN score sc ON js.score_id = sc.score_id
         JOIN celebrity_season cs ON js.celebrity_season_id = cs.celebrity_season_id
         JOIN celebrity c ON cs.celebrity_id = c.celebrity_id
         JOIN season s ON cs.season_id = s.season_id
         JOIN pros p ON cs.pro_id = p.pro_id
GROUP BY cs.celebrity_season_id,
         cs.celebrity_id,
         c.celebrity_name,
         s.season_number,
         sc.week
ORDER BY cs.celebrity_season_id,
         sc.week;

-- 2) Creating a Stored Procedure (Given a celebrity_name, returns a full list of seasons, dance styles, and weeks in which that celebrity performed — ordered chronologically)
CREATE OR REPLACE PROCEDURE get_celebrity_dance_history(celeb_name VARCHAR)
    LANGUAGE plpgsql
AS
$$
DECLARE
    rec RECORD;
BEGIN
    RAISE NOTICE 'Dance History for %:', celeb_name;

    FOR rec IN
        SELECT s.season_number,
               dp.week,
               ds.dance_name
        FROM celebrity c
                 JOIN celebrity_season cs ON c.celebrity_id = cs.celebrity_id
                 JOIN dances_performed dp ON cs.celebrity_season_id = dp.celebrity_season_id
                 JOIN dance_styles ds ON dp.dance_id = ds.dance_id
                 JOIN season s ON cs.season_id = s.season_id
        WHERE c.celebrity_name = celeb_name
        ORDER BY s.season_number, dp.week
        LOOP
            RAISE NOTICE 'Season % - Week %: %', rec.season_number, rec.week, rec.dance_name;
        END LOOP;
END;
$$;

-- 3) Creating a Function (function to find which season certain ballroom partners performed, their placement, and their celebrity partners.)
CREATE OR REPLACE FUNCTION pro_seasons(
    ballroom_part VARCHAR(50),
    season_data INTEGER
)
RETURNS TABLE (
    ballroom_partner VARCHAR(50),
    placement INTEGER,
    season INTEGER,
    celebrity_partner VARCHAR(50)
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.pro_name,
        cs.placement,
        cs.season_id,
        c.celebrity_name
    FROM celebrity_season cs
    JOIN pros p ON cs.pro_id = p.pro_id
    JOIN celebrity c ON cs.celebrity_id = c.celebrity_id
    WHERE p.pro_name = ballroom_part AND cs.season_id = season_data;
END;
$$ LANGUAGE plpgsql;

-- Testing my view/procedure:
-- drop view if exists total_scores
-- drop procedure get_celebrity_dance_history(celeb_name VARCHAR)
-- drop function if exists pro_seasons(character varying, integer);